프로그래밍 언어의 타입검사가 가장 중요한 성질 중 하나이다.
타입 검사의 장단점은 무엇인가? 타입 검사의 장점은 키우고 단점은 줄이려면 어떻게 해야하는가? 를 알 수 있다.
타입 검사의 정의와 필요성 - 버그 중 타입 오류가 많은데 타입 검사기가 필요하다
타입 안정성
타입 별로 능력이 다르다

타입 검사의 원리
타입 검사기도 작은 부품에서 큰 부품으로 가면서 프로그램을 검사한다.
타입 검사 결과의 활용
정적 타입 언어의 장점
타입 오류를 빠트리지 않고 모두 찾을 수 있다
타입 검사기의 오류 메시지 덕분에 코드를 올바르게 고치기 쉽다
타입 검사기가 코드 편집기의 기능을 보조하여 개발자의 생산성을 높인다
프로그램의 실행 시간이 짧다.

정적타입언어의 단점 - 개발자가 타입 표시를 제공해야 한다.
타입 표시는 많은 정보를 준다. 절대 낡지 않는 주석이다.
타입 추론 - 초깃값이 주어진다면 타입 검사기는 변수의 타입을 쉽게 찾을 수 있다.
개발자가 타입 표시를 생략해 코드를 간결하게 만드는 데 도움이 된다.
타입 검사의 결과에 영향을 주지 않는다. 생략할 수 있게 할 뿐이다.
생략된 타입 표시를 복구할 뿐이다.
더 세밀한 타입 - 자바와 코틀린에서의 널의 타입(string/null).
타입검사기가 거부라고 잘못 말하는 상황을 해결하는 기능(틀 안에서의 안전한 기능, 타입검사를 무력화하는 위험한 기능)
다형성 - 안전한 기능의 대부분을 차지하는 개념. 한 개체가 여러 타입에 속하게 만든다.
앞으로 어떤 개체에 다형성을 부여하는지, 어떻게 다형성을 부여하는지에 따라 서브타입에 의한 다형성, 매개변수에 의한 다형성, 오버로딩에 의한  다형성으로 나누어 설명할 것이다.

A는 B다.에서 A는 B의 서브타입 B는 A의 슈퍼타입
서브 타입에 의한 다형성 : A타입의 부품을 B타입으로도 간주할 수 있게 하는 기능
이름에 의한 서브타입 - 상속 관계만 고려 (직접, 간접 포함)
구조에 의한 서브타입 - 클래스에 어떤 필드와 메서드가 있는지 고려
A가 B에 정의된 필드와 메서드를 모두 정의한다면 A는 B의 서브타입이다
추상 메서드 : 몸통이 없고 시그니처만 가짐
추상 클래스 : 추상 메서드를 가지는 대신 객체를 직접 만들 수 없는 클래스

최대 타입 : 모든 타입은 최대 타입의 서브타입이다.
최소 타입 : 최소 타입은 모든 타입의 서브타입이다. 어떤 값도 속하지 않는 타입.
이거나 타입 : A와 B는 A|B의 서브타입이다. 위치에 민감한 타입 검사 사용. 합집합 타입
이면서 타입 : C가 A의 서브타입이면서 B의 서브타입이면 C는 A&B의 서브타입이다. 교집합 타입
함수타입 : A가 B의 서브타입이고 C가 D의 서브타입이면 B => C 는 A => D의 서브타입이다. 매개변수 타입의 서브타입 관계를 뒤집고 결과 타입의 서브타입 관계를 유지한다.

매개변수에 의한 다형성은 타입 매개변수를 통해 다형성을 만드는 기능, 제네릭스이다
제네릭 메서드는 클래스 안에 정의된다.
타입 인자 추론
힌들리-밀너 타입 추론 : 제네릭 함수를 정의할 때 조차 타입 추론을 한다.

제네릭 타입 : 타입에 타입 매개변수를 추가하면 제네릭 타입이 된다
제네릭 클래스 : 자신만의 제네릭 타입을 직접 정의할 수 있는 기능, 타입 매개변수를 가진 클래스

무엇이든 타입 : 보편양화타입.  forall T.A형태. 제네릭 함수의 타입으로 이해할 수 있다. 최소 타입과 비슷.
제네릭 함수를 값으로 사용하면 그 타입이 무엇이든 타입이 되고, 무엇이든 타입의 값을 사용할 때는 제네릭 함수를 사용하듯이 하면 된다.
무엇인가 타입 :  존재양화타입. exist T.A 형태. 최대 타입과 비슷.
타임스탬프의 타입이 라이브러리 사용자에게 노출되는 것은 라이브러리를 만드는 입장에서 바람직하지 않다.
라이브러리 코드를 고치면, 프로그램의 동작이 달라지거나 아예 타입 검사를 통과하지 못하게 될 수 있는 것이다.
타임스탬프의 타입을 라이브러리 사용자에게 숨겨야 한다.
그래서 라이브러리 사용자의 행동을 제약할 필요가 있다. 특정 조건을 만족한다고 가정해야 코드를 작성하기 쉽거나 앞으로 코드를 고치는 데 유리하기 때문이다.

제네릭 클래스와 상속
제네릭 클래스를 상속과 함께 사용하는 방법.
어떤 클래스를 상속해 새로운 클래스를 정의하면 기존 클래스에 정의된 필드와 메서드가 새 클래스에도 자동으로 정의된다.
ArrayList<T> 와 LinkedList<T>는 추상클래스인 List<T>의 구현 클래스이다.
타입 인자가 특정 타입일 때만 상속할 것이라면 BitVector extends List<Boolean> 으로 씀.
C<T> extends D : C<A> 는 타입 D에 등장하는 모든 T를 A로 바꿔서 만든 타입의 서브타입이다.
타입 매개변수 제한
타입이 가지고 있는 능력 중에 모든 타입이 가지고 있지는 않지만 한 타입만 가지고 있지도 않은 몇몇 타입이 가지고 있는 능력도 있다.
타입 매개변수 제한을 사용한 제네릭 함수를 사용할 때는 정의된 상한을 타입 인자가 따라야 한다.
제네릭 함수 뿐만 아니라 제네릭 클래스 역시 타입 매개변수 제한을 할 수 있다.
언어마다 매개변수에 상한, 하한을 지정할 수 있다
재귀적 타입 매개변수 제한
타입 매개변수가 자기 자신을 제한하는 데 사용될 수 있다.
T가 Comparable<T>의 서브타입일 때 T 타입의 갑을 T 타입의 값과 비교할 수 있다.
재귀적 타입 매개변수 제한은 제네릭 클래스를 정의할 때도 가능하다.

가변성
가변성은 제네릭 타입 사이의 서브타입 관계를 추가로 정의하는 기능이다.
가변성은 하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브타입 관계를 만든다.
B가 A의 서브타입일 때 List<B>가 List<A>의 서브타입이 되어도 될까?
List가 원소 읽기만 허용하면 그래도 되고, 원소 추가도 허용하면 그렇지 않다.
제네릭 타입과 타입 인자 사이의 관계를 분류할 수 있다.

함수 오버로딩 : 매개변수 타입이 서로 다른 같은 이름의 함수를 여러개 정의하는 것
함수 선택 : 함수가 오버로딩 되어 있을 때 호출할 함수를 자동으로 고르는 것
오버로딩에 의한 다형성
함수 선택 규칙. 인자의 타입에 가장 특화된 함수를 고른다
정적 선택 : 정적 타입을 바탕으로 함수를 선택하는 것
함수 오버로딩은 서로 완전히 다른 타입들의 값을 인자로 받는 함수를 정의하는 용도로 사용할 것
메서드 오버로딩과 메서드 선택
메서드 오버라이딩 : 클래스를 상속해서 자식 클래스에 메서드를 새로 정의할 때 메서드의 이름과 매개변수 타입을 부모 클래스에 정의되어 있는 메서드와 똑같게 정의하는 것
동적 선택 : 메서드를 고를 때는 수신자의 동적 타입도 고려한다.
자식 클래스에 정의한 메서드의 결과 타입이 부모 클래스에 원래 있는 메서드의 결과 타입의 서브타입이어야 한다.

타입 클래스는 특정 타입을 위한 어떤 함수가 존재한다는 사실을 표현한다.
타입이 만족해야하는 조건을 표현한다.
함수는 아무 때나 정의할 수 있지만 메서드는 클래스를 정의할 때만 정의할 수 있다.
라이브러리에 정의된 타입을 특정 추상 클래스의 서브타입으로 만드는 것은 일반적으로 불가능하지만, 특정 타입클래스에 속하게 만들기는 매우 쉽다.
추상클래스로는 특정 타입 인자를 받은 제네릭 타입만이 만족하는 성질을 표현하기 어렵지만 타입클래스로는 쉽게 가능하다.
타입클래스로는 항상 만족하는 성질은 물론이고 특정 타입 인자를 받은 경우에만 만족하는 성질 역시 표현할 수 있다.
카인드 : 타입의 타입
어떤 타입을 매개변수 타입이나 결과 타입으로 사용할 수 있다는 말은 그 타입에 속하는 값이 존재한다는 것이다.
타입의 값들이 존재하지 않는 타입들을 표현
